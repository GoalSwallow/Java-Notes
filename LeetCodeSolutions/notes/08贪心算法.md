# [第八章 贪心算法](#贪心算法)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [8-1 贪心基础 Assign Cookies](#贪心基础) | [455](#455) | [392](#392) | [561](#561) | |
| [8-2 贪心算法与动态规划的关系 Non-overlapping Intervals](#贪心算法与动态规划的关系) | [435](#435) | [无] | | |
| [8-3 贪心选择性质的证明](#贪心选择性质的证明) | [无] | [无] | | |
| [补充1：更多贪心问题](#更多贪心问题) | [无] | [无] | [860](#860) [861](#861) [870](#870) [881](#881) | 765 |

# 贪心算法
## 贪心基础
### 455
[455 Assign Cookies](https://leetcode.com/problems/assign-cookies/description/)

* 问题：

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。
但是，每个孩子最多只能给一块饼干。
对每个孩子 i ，都有一个胃口值 g(i) ，这是能让孩子们满足胃口的饼干的最小尺寸；
并且每块饼干 j ，都有一个尺寸 s(j) 。如果 s(j) >= g(i) ，
我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

* 示例：

g=[1,2,3],s=[1,1],结果为1

g=[1,2],s=[1,2,3]，结果为2

* 解题：

贪心策略：每次选取最大的饼干给最"贪心"的小朋友。

```java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int gi=g.length-1;
    int si=s.length-1;
    int res=0;
    while(gi>=0 && si>=0){
        if(s[si]>=g[gi]){
            res++;
            gi--;
            si--;
        }else{
            //对于不能满足的小朋友，就不分发给他了。
            gi--;
        }
    }
    return res;
}
```

### 392
[392 Is Subsequence](https://leetcode.com/problems/is-subsequence/description/)
```java
public boolean isSubsequence(String s, String t) {
    if (s.length()==0){
        return true;
    }


    for (int i = 0,j = 0; j < t.length(); j++) {
        if (t.charAt(j) == s.charAt(i)) {
            i++;
            if (i == s.length())
                return true;
        }
    }
    return false;
}
```

### 561
[561 Array Partition I](https://leetcode.com/problems/array-partition-i/)
```java
public int arrayPairSum(int[] nums) {
    int n=nums.length/2;
    if(n==1){
        return Math.min(nums[0],nums[1]);
    }
    Arrays.sort(nums);
    int res=0;
    /*for(int i=0;i<=2*n-2;i+=2){
        res+=Math.min(nums[i],nums[i+1]);
    }*/
    //改进
    for(int i=0;i<=2*n-2;i+=2){
        res+=nums[i];
    }
    return res;
}
```

## 贪心算法与动态规划的关系 
### 435
[435 Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/)

* 问题:

给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。

* 示例：

[1,2],[2,3],[3,4],[1,3]，算法返回1

[1,2][1,2][1,2],算法返回2

* 解题：

解法一：按照区间开始值，进行排序，将该问题转化为最长上升子序列问题。

```java
public int eraseOverlapIntervals(Interval[] intervals) {
    int n=intervals.length;
    if(n==0){
        return 0;
    }
    Arrays.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            //按照开始时间升序排序
            int num=o1.start-o2.start;
            int num2=(num==0)?o1.end-o2.end:num;
            return num2;
        }
    });
    int[] memo=new int[n];
    for(int i=0;i<n;i++){
        memo[i]=1;
    }
    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(intervals[i].start>=intervals[j].end){
                memo[i]=Math.max(memo[i],1+memo[j]);
            }
        }
    }
    int res=0;
    for(int i=0;i<n;i++){
        res=Math.max(res,memo[i]);
    }
    return n-res;
}
```

解法二：贪心策略，按照结束时间进行升序排列，每次选择最小结束区间。
```java
public int eraseOverlapIntervals(Interval[] intervals) {
    int n = intervals.length;
    if (n == 0) {
        return 0;
    }
    Arrays.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            int num=o1.end-o2.end;
            int num2=(num==0)?o1.start-o2.start:num;
            return num2;
        }
    });

    int res=1;
    int pre=0;
    for(int i=1;i<n;i++){
        if(intervals[i].start>=intervals[pre].end){
            res++;
            pre=i;
        }
    }
    return n-res;
}
```

## 贪心选择性质的证明
无法使用贪心算法，举出反例即可。

比如0-1背包问题:

<div align="center"><img src="pics//greedyAlgorithms//ga_1.png" width="600"/></div>

再比如完全平方数问题：

12=4+4+4

使用贪心策略(每次选取最大的平方数)：

12=9+1+1+1

如何证明贪心策略的正确性？**反证法**

对于问题：给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。

贪心算法：按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间。

某次选择是[s(i),f(i)];其中f(i)是当前选择中结尾最早的。

反证：假设这个选择不是最优的。最优解在这一步选择[s[j],f[j]],则f[j]>=f[i]。

显然，可以将[s[j],f[j]]替换成[s(i),f(i)]，而不影响后续的区间选择。

此时，当我们选择[s(i),f(i)]是最优解。

矛盾。

## 更多贪心问题 
### 860 
[860 Lemonade Change](https://leetcode.com/problems/lemonade-change/)
```java
/**
 * 思路：
 * 统计收到的这三种硬币。
 * 我们知道：
 * $5 是不用找的
 * $10 就需要找$5
 * $20 就需要找$10和$5或者3个$5
 */
public boolean lemonadeChange(int[] bills) {
    //统计收到的三种硬币
    int five=0;
    int ten=0;
    int tewnty=0;
    for(int bill:bills){
        if(bill==5){
            five++;
        }else if(bill==10){
            ten++;
            if(five==0){
                return false;
            }else{ //找出$5
                five--;
            }
        }else{ //bill==20
            tewnty++;
            if(ten>0 && five>0){ //找$10和$5
                ten--;
                five--;
            }else if(five>=3){ //3个$5
                five-=3;
            }else{
                return false;
            }
        }
    }
    return true;
}
```

### 861 
[861 Score After Flipping Matrix](https://leetcode.com/problems/score-after-flipping-matrix/)
```java
/**
 * 思路:
 * 返回尽可能高分这个要求，理解为对同一组数，高位尽可能置1，对不同组的相同位尽可能多的置1。
 * (1)判断最高位是否为1，如果不是1，移动当前行。
 * (2)判断每列的的0的个数，如果0较多，移动当前列。
 * @param A
 * @return
 */
public int matrixScore(int[][] A) {
    int R=A.length;
    int C=A[0].length;
    for(int i=0;i<R;i++){
        if(A[i][0]==0){ //最高位如果不是1，移动当前行
            for(int j=0;j<C;j++){
                A[i][j]=1-A[i][j];
            }
        }
    }
    for(int j=0;j<C;j++){
        //统计每列的0和1
        int zero=0;
        int one=0;
        for(int i=0;i<R;i++){
            if(A[i][j]==0){
                zero++;
            }
            if(A[i][j]==1){
                one++;
            }
        }
        if(zero>one){
            //反转当前列
            for(int i=0;i<R;i++){
                A[i][j]=1-A[i][j];
            }
        }
    }
    int res=0;
    for(int i=0;i<R;i++){
        for(int j=0;j<C;j++){
            res+=A[i][j]*Math.pow(2,(int)(C-j-1));
        }
    }
    return res;
}
```

### 870 
[870 Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/)
```java
/**
 * 贪心策略：
 * 每次讲A中第一大的数对上B中刚好小于这个数的数。依次类推。
 * “田忌赛马"：每次都拿最优的马和对手刚好比我最优马弱一点的马比
 */
public int[] advantageCount(int[] A, int[] B) {
    int len = A.length;

    //复制B数组到C数组中
    int[] C = new int[len];
    for (int i = 0; i < len; i++) {
        C[i] = B[i];
    }

    Arrays.sort(A);
    Arrays.sort(C);

    //定义一个临时数组，用于补全res中缺失的数据
    int[] tmp = new int[len];
    int k = 0;
    int n = len;
    for (int indexA = 0, indexC = 0; indexA < len; indexA++, indexC++) {
        if (A[indexA] <= C[indexC]) {
            //"劣马"就放在后面
            tmp[--n] = A[indexA];
            indexC--;
        } else {
            //“田忌赛马"：每次都拿最优的马和对手刚好比我最优马弱一点的马比
            tmp[k++] = A[indexA];
        }
    }

    int[] res = new int[len];

    // 有序数组进行优势洗牌后，还原成原始顺序，
    // 这时候，通过之前保留的一个数组顺序和他对应的排序数组的关系
    // 可以找出洗牌后数组的原始顺序
    for (int i = 0; i < len; i++) {
        for (int j = 0; j < len; j++) {
            if (B[i] == C[j]) {
                res[i] = tmp[j];
                C[j] = -1;
                //结束里面的for循环，提高效率
                break;
            }
        }
    }
    return res;
}
```

### 881
[881 Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)

```java
/**
 * 先进行排序：
 * people[i] + people[j] <= limit 判断最大重量，最小重量之和
 * 如果两者之和小于那么能够被船承载，然后改变索引判断下一个最大值和最小值
 * 如果两者之和大于 limit，那么最大值被筛选出并单独坐一艘船，
 */
public int numRescueBoats(int[] people, int limit) {
    Arrays.sort(people);

    int i = 0, j = people.length - 1;
    int res = 0;
    while(i <= j){
        //每条船尽量多搭重量轻的人
        if(people[i] + people[j] <= limit){
            i ++;
            j --;
        }
        else{
            j--;
        }
        res ++;
    }
    return res;
}
```