# [第八章 贪心算法](#贪心算法)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [8-1 贪心基础 Assign Cookies](#贪心基础) | [455](#455) | [392](#392) | 561 | |
| [8-2 贪心算法与动态规划的关系 Non-overlapping Intervals](#贪心算法与动态规划的关系) | [435](#435) | [无] | | |
| [8-3 贪心选择性质的证明](#贪心选择性质的证明) | [无] | [无] | | |
| [补充1：更多贪心问题](#更多贪心问题) | [无] | [无] | 860 861 870 881 | 765 |

# 贪心算法
## 贪心基础
### 455
[455 Assign Cookies](https://leetcode.com/problems/assign-cookies/description/)

* 问题：

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。
但是，每个孩子最多只能给一块饼干。
对每个孩子 i ，都有一个胃口值 g(i) ，这是能让孩子们满足胃口的饼干的最小尺寸；
并且每块饼干 j ，都有一个尺寸 s(j) 。如果 s(j) >= g(i) ，
我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

* 示例：

g=[1,2,3],s=[1,1],结果为1

g=[1,2],s=[1,2,3]，结果为2

* 解题：

贪心策略：每次选取最大的饼干给最"贪心"的小朋友。

```java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int gi=g.length-1;
    int si=s.length-1;
    int res=0;
    while(gi>=0 && si>=0){
        if(s[si]>=g[gi]){
            res++;
            gi--;
            si--;
        }else{
            //对于不能满足的小朋友，就不分发给他了。
            gi--;
        }
    }
    return res;
}
```

### 392
[392 Is Subsequence](https://leetcode.com/problems/is-subsequence/description/)
```java
public boolean isSubsequence(String s, String t) {
    if (s.length()==0){
        return true;
    }


    for (int i = 0,j = 0; j < t.length(); j++) {
        if (t.charAt(j) == s.charAt(i)) {
            i++;
            if (i == s.length())
                return true;
        }
    }
    return false;
}
```

## 贪心算法与动态规划的关系 
### 435
[435 Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/)

* 问题:

给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。

* 示例：

[1,2],[2,3],[3,4],[1,3]，算法返回1

[1,2][1,2][1,2],算法返回2

* 解题：

解法一：按照区间开始值，进行排序，将该问题转化为最长上升子序列问题。

```java
public int eraseOverlapIntervals(Interval[] intervals) {
    int n=intervals.length;
    if(n==0){
        return 0;
    }
    Arrays.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            //按照开始时间升序排序
            int num=o1.start-o2.start;
            int num2=(num==0)?o1.end-o2.end:num;
            return num2;
        }
    });
    int[] memo=new int[n];
    for(int i=0;i<n;i++){
        memo[i]=1;
    }
    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(intervals[i].start>=intervals[j].end){
                memo[i]=Math.max(memo[i],1+memo[j]);
            }
        }
    }
    int res=0;
    for(int i=0;i<n;i++){
        res=Math.max(res,memo[i]);
    }
    return n-res;
}
```

解法二：贪心策略，按照结束时间进行升序排列，每次选择最小结束区间。
```java
public int eraseOverlapIntervals(Interval[] intervals) {
    int n = intervals.length;
    if (n == 0) {
        return 0;
    }
    Arrays.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            int num=o1.end-o2.end;
            int num2=(num==0)?o1.start-o2.start:num;
            return num2;
        }
    });

    int res=1;
    int pre=0;
    for(int i=1;i<n;i++){
        if(intervals[i].start>=intervals[pre].end){
            res++;
            pre=i;
        }
    }
    return n-res;
}
```

## 贪心选择性质的证明
无法使用贪心算法，举出反例即可。

比如0-1背包问题:

<div align="center"><img src="pics//greedyAlgorithms//ga_1.png" width="600"/></div>

再比如完全平方数问题：

12=4+4+4

使用贪心策略(每次选取最大的平方数)：

12=9+1+1+1

如何证明贪心策略的正确性？**反证法**

对于问题：给定一组区间，问最少删除多少个区间，可以让这些区间之间互相不重叠。

贪心算法：按照区间的结尾排序，每次选择结尾最早的，且和前一个区间不重叠的区间。

某次选择是[s(i),f(i)];其中f(i)是当前选择中结尾最早的。

反证：假设这个选择不是最优的。最优解在这一步选择[s[j],f[j]],则f[j]>=f[i]。

显然，可以将[s[j],f[j]]替换成[s(i),f(i)]，而不影响后续的区间选择。

此时，当我们选择[s(i),f(i)]是最优解。

矛盾。

## 更多贪心问题 