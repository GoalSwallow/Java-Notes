# [第十二章 数据结构](#数据结构)

| 章节 | 典型题目 | 相关题目 |
| :---: | :---: | :---: |
| [12-1 并查集](#并查集) |  [684](#684)  721 | |
| [12-2 线段树](#线段树) | 307 370 218 | 699 715 308 |
| [12-3 Trie](#Trie) | [208](#208) [720](#720) 676 677 648 211 | |
| [12-4 图论](#图论) | 787 886 | 685 765 864 882 |
| [12-5 数据结构设计](#数据结构设计) | [155](#155) [380](#380) 900 | 381 895 |

# 数据结构
## 并查集
### 684
[684 Redundant Connection](https://leetcode.com/problems/redundant-connection/)

```java
/**
 * 思路：
 * 判断无向图是否有环可以使用并查集来判断。
 * 新加入的边若两个点的根节点相同，则形成环，
 * 这是因为这条边中一定要有一个结点是新加入集合的。
 */
public int[] findRedundantConnection(int[][] edges) {
    //edges的size在[3,1000]之间
    int N = edges.length;

    //顶点的编号在 [1,N]之间
    int[] parent = new int[N+1];
    //初始化时，每个点都是一棵树，就看成森林
    for(int i=1;i<=N;i++){
        parent[i]=i;
    }

    //遍历每条边的顶点
    for(int i=0;i<N;i++){
        int p1=find(parent,edges[i][0]);
        int p2=find(parent,edges[i][1]);
        //这两个顶点的是同一个父结点，说明构成了环。
        if(p1==p2){
            return edges[i];
        }
        //既然是图，那么各个顶点所在树的根结点必然相连的
        parent[p1] = p2;
    }
    return new int[]{0,0};
}

//查找p元素所在的树（也就是集合）的根节点
//时间复杂度：O(h),其中h为该集合树的深度
private int find(int[] parent,int p){
    if(p<0 || p>=parent.length){
        throw new IllegalArgumentException("p is out of bound.");
    }
    while(p!=parent[p]){
        p=parent[p];
    }
    //返回的是p所在的集合的编号，同时也是p集合非根节点
    return p;
}
```

### 721

## Trie
### 208
```java
class Trie {
    private class Node{
        public boolean isWord;//标记该字符是否是单词结尾
        public TreeMap<Character,Node> next;
        public Node(boolean isWord){
            this.isWord=isWord;
            next=new TreeMap<>();
        }
        public Node(){
            this(false);
        }
    }

    private Node root;
    
    /** Initialize your data structure here. */
    public Trie() {
        root=new Node();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Node cur=root;
        for(int i=0;i<word.length();i++){
            char c=word.charAt(i);
            if(cur.next.get(c)==null){
                cur.next.put(c,new Node());
            }
            cur=cur.next.get(c);
        }
        //循环结束后，cur不一定是叶子节点，比如Trie中已经有 "panda"，此时add("pan"),
        // cur指向'n'节点，显然'n'不是叶子节点,那么就要标记为结束位置
        if(!cur.isWord){
            //!cur.isWord 表示该节点未被标识为结束位置
            cur.isWord=true;
        }
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Node cur=root;
        for(int i=0;i<word.length();i++){
            char c=word.charAt(i);
            if(cur.next.get(c)==null){
                return false;
            }
            cur=cur.next.get(c);
        }
        //注意：即使循环结束了，也不一定能确定该单词就在Trie中
        //如果Trie中已经有单词"panda"，此时要查询"pan"
        //循环结束后,cur此时指向'n'节点,'n'节点不是结尾节点,即"pan"不在Trie中
        return cur.isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Node cur=root;
        for(int i=0;i<prefix.length();i++){
            char c=prefix.charAt(i);
            if(cur.next.get(c)==null){
                return false;
            }
            cur=cur.next.get(c);
        }
        //注意：循环结束后,cur不管是单词的结尾节点还是非结尾节点，都成立
        //单词本身就是该单词的前缀
        return true;
    }
}
```

### 720
[720 Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/)
```java

```

## 数据结构设计
### 155
[155 Min Stack](https://leetcode.com/problems/min-stack/description/)
```java
class MinStack {
    //准备两个栈，一个用来存普通元素，一个栈顶的元素始终是当前最小值
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack=new Stack<>();
        minStack=new Stack<>();
    }

    public void push(int x) {
        if(minStack.isEmpty() || x<=minStack.peek()){
            minStack.push(x);
        }
        stack.push(x);
    }

    public void pop() {
        if(stack.peek().equals(minStack.peek())){
            minStack.pop();
        }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### 380
[380 Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)
```java
class RandomizedSet {
    //存储插入的数据
    private ArrayList<Integer> data;
    //存储<value,index>，即存储该值和该值的下标
    private Map<Integer,Integer> valueIndex;
    private Random random;

    /** Initialize your data structure here. */
    public RandomizedSet() {
        data=new ArrayList<>();
        valueIndex=new HashMap<>();
        random=new Random();
    }

    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(!valueIndex.containsKey(val)){
            valueIndex.put(val,data.size());
            data.add(val);
            return true;
        }
        return false;
    }

    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        //这里讲要删除的元素交换到data的最后一个位置，实际上就是将最后一个元素值赋值到val位置，这样保证时间复杂度是O(1)
        if(valueIndex.containsKey(val)){
            //获取val位置
            int index=valueIndex.get(val);
            //val不是最后一个元素
            if(index!=data.size()-1){
                //获取最后一个元素
                int lastEle=data.get(data.size()-1);
                //将最后一个元素值赋值到val位置
                data.set(index,lastEle);
                valueIndex.put(lastEle,index);
            }
            //删除data中最后一个元素
            data.remove(data.size()-1);
            valueIndex.remove(val);
            return true;
        }
        return false;
    }

    /** Get a random element from the set. */
    public int getRandom() {
        return data.get(random.nextInt(data.size()));
    }
}
```

### 900
[900 RLE Iterator](https://leetcode.com/problems/rle-iterator/)