# [第十章 数学](#数学)

| 章节 | 典型题目 | 相关题目 |
| :---: | :---: | :---: |
| [10-1 素数](#素数) | [204](#204) | |
| [10-2 最大公约数](#最大公约数)| | |
| [10-3 进制转换](#进制转换) | [504](#504) [405](#405) [168](#168) [171](#171)  | |
| [10-4 阶乘](#阶乘) | [172](#172) | |
| [10-5 字符串加法减法](#字符串加法减法) | [67](#67) [415](#415) | |
| [10-6 相遇问题](#相遇问题) | [462](#462) | |
| [10-7 多数投票问题](#多数投票问题) | [169*](#169) | |
| [10-8 随机算法](#随机算法) |  [478]($478) [497](#497) 519 528 | 710 |
| [10-9 其他](#其他) |  367 326 238 628 |  |  |

# 数学
## 素数
- 素数分解 

每一个数都可以分解成素数的乘积，
例如 84 = 2<sup>2</sup> \* 3<sup>1</sup> \* 5<sup>0</sup> \* 7<sup>1</sup> \* 11<sup>0</sup> \* 13<sup>0</sup> \* 17<sup>0</sup> \* …

- 整除

令 x = 2<sup>m0</sup> \* 3<sup>m1</sup> \* 5<sup>m2</sup> \* 7<sup>m3</sup> \* 11<sup>m4</sup> \* …

令 y = 2<sup>n0</sup> \* 3<sup>n1</sup> \* 5<sup>n2</sup> \* 7<sup>n3</sup> \* 11<sup>n4</sup> \* …

如果 x 整除 y（y mod x == 0），则对于所有 i，mi <= ni。

- 最大公约数最小公倍数
  
x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> \* 3<sup>min(m1,n1)</sup> \* 5<sup>min(m2,n2)</sup> \* ...
  
x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> \* 3<sup>max(m1,n1)</sup> \* 5<sup>max(m2,n2)</sup> \* ...

### 204
[204 Count Primes](https://leetcode.com/problems/count-primes/)

```java
/**
 * 思路：
 * 在每次找到一个素数时，将能被素数整除的数排除掉。
 */
public int countPrimes(int n) {
    //下标对应 0--> n 的数据，元素值表示该元素是否是素数。true 表示不是素数，false表示是素数
    boolean[] notPrimes=new boolean[n+1];
    int count=0;
    //2 是最小的素数，i<n即可，因为是统计小于n的素数的个数
    for(int i=2;i<n;i++){
        if(notPrimes[i]){
            continue;
        }
        count++;
        for(long j=(long)(i)*i;j<n;j+=i){
            notPrimes[(int)j]=true;
        }
    }
    return count;
}
```

## 最大公约数
- 求a、b的最大公约数
```java
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```
- 求a、b的最小公倍数

最小公倍数为两数的乘积除以最大公约数。

```java
int lcm(int a, int b) {
    return a * b / gcd(a, b);
}
```

- **使用位操作和减法求解最大公约数**

对于 a 和 b 的最大公约数 f(a, b)，有：

如果 **a 和 b 均为偶数**，f(a, b) = 2*f(a/2, b/2);

如果 **a 是偶数 b 是奇数**，f(a, b) = f(a/2, b);

如果 **a 是奇数 b 是偶数**，f(a, b) = f(a, b/2);

如果 **a 和 b 均为奇数**，f(a, b) = f(b, a-b);

```java
public int gcd(int a, int b) {
    if (a < b) {
        return gcd(b, a);
    }
    if (b == 0) {
        return a;
    }
    boolean isAEven = isEven(a), isBEven = isEven(b);
    if (isAEven && isBEven) {
        return 2 * gcd(a >> 1, b >> 1);
    } else if (isAEven && !isBEven) {
        return gcd(a >> 1, b);
    } else if (!isAEven && isBEven) {
        return gcd(a, b >> 1);
    } else {
        return gcd(b, a - b);
    }
}

//判断n是否是偶数
private boolean isEven(int n){
    if(n % 2==0){
        return true;
    }
    return false;
}
```

## 进制转换

### 504 
[504 Base 7](https://leetcode.com/problems/base-7/)

```java
public String convertToBase7(int num) {
    if(num==0){
        return "0";
    }
    StringBuilder res=new StringBuilder();

    //判断num是否是正数
    boolean isNegative=false;
    if(num<0){
        num=-num;
        isNegative=true;
    }

    while(num!=0){
        res.append(num % 7);
        num /=7;
    }
    String ret=res.reverse().toString();
    return isNegative? ("-"+ret): ret;
}
```

### 405 
[405 Convert a Number to Hexadecimal](https://leetcode.com/problems/convert-a-number-to-hexadecimal/)

```java
/**
 * 思路：
 * 本质上就是获取10进制的数的补码
 */
public String toHex(int num) {
    if(num==0){
        return "0";
    }
    char[] map = {
            '0','1','2','3','4','5','6','7',
            '8','9', 'a','b','c','d','e','f'
    };

    StringBuilder res=new StringBuilder();
    while (num != 0){
        //num & 0b1111 每次获取 num 的4位的补码
        res.append( map [num & 0b1111]);
        //无符号右移四位
        num = num >>> 4;
    }
    return res.reverse().toString();
}
```

### 168
[168 Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/)

```java
/**
 * 思路一：
 * 实际上就是将n转化为26进制的数字
 */
public String convertToTitle(int n) {
    String[] num_char = {
            "A","B","C","D","E","F","G","H","I","J","K","L","M",
            "N","O","P","Q","R","S","T","U","V","W","X","Y","Z"
    };
    StringBuilder res=new StringBuilder();
    n--;
    while(n >= 0){
        res.append(num_char[n % 26]);
        n /=26;
        n--;
    }
    return res.reverse().toString();
}
```

```java
/**
 * 思路二：递归写法
 */
private String[] map = {
        "A","B","C","D","E","F","G","H","I","J","K","L","M",
        "N","O","P","Q","R","S","T","U","V","W","X","Y","Z"
};

public String convertToTitle(int n) {
    if(n==0){
        return "";
    }
    n--;
    return convertToTitle(n/26) + map[n%26];
}
```

### 171
[171 Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/)
```java
/**
 * 思路：
 * 看成二十六进制就好了
 */
public int titleToNumber(String s) {
    // 'A'就对应1
    // 'B'就对应2
    char[] arr = {
            1,2,3,4,5,6,7,
            8,9,10,11,12,13,14,
            15,16,17,18,19,20,21,
            22,23,24,25,26
    };

    int res=0;
    for(int i=s.length()-1;i>=0;i--){
        char c=s.charAt(i);
        res+= arr[c-'A']*Math.pow((int)26,(int)(s.length()-1-i));
    }
    return res;
}
```

## 阶乘
### 172
[172 Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes/)

- 思路：

尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，
因此只要统计有多少个 5 即可。

对于一个数 N，它所包含 5 的个数为：
N/5 + N/5<sup>2</sup> + N/5<sup>3</sup> + ...，
其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，
N/5<sup>2</sup> 表示不大于 N 的数中 5<sup>2</sup> 的倍数再贡献一个 5 ...。

```java
/**
 * 递归写法
 */
public int trailingZeroes(int n) {
    return n==0? 0 : n/5 + trailingZeroes(n/5);
}
```

```java
/**
 * 非递归写法
 */
public int trailingZeroes(int n) {
    int res=0;
    while(n!=0){
        n /= 5;
        res += n;
    }
    return res;
}
```
如果统计的是 N! 的**二进制表示中最低位 1 的位置**，只要统计有多少个 2 即可。
和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup> + N/2<sup>3</sup> + ...

## 字符串加法减法
### 67
[67 Add Binary](https://leetcode.com/problems/add-binary/)

```java
/**
 * 思路:从后向前相加
 */
public String addBinary(String a, String b) {
    int i=a.length()-1;
    int j=b.length()-1;

    //a,b上各个二进制位相加所得的结果
    int c=0;

    StringBuilder res=new StringBuilder();
    //c==1 是考虑像 Example 1 这种情况
    while(i>=0 || j>=0 || c==1) {
        //a = "11", b = "1" 实际上就变成 a = "11",b = "01"
        c += (i >= 0) ? a.charAt(i) - '0' : 0;
        c += (j >= 0) ? b.charAt(j) - '0' : 0;
        res.append(c%2);
        c /= 2;
        i--;
        j--;
    }
    return res.reverse().toString();
}
```
 
### 415 
[415 Add Strings](https://leetcode.com/problems/add-strings/)

```java
public String addStrings(String num1, String num2) {
    int i=num1.length()-1;
    int j=num2.length()-1;

    int c=0;

    StringBuilder res=new StringBuilder();
    while(i>=0 || j>=0 || c==1){
        c += (i>=0) ? num1.charAt(i)-'0' : 0;
        c += (j>=0) ? num2.charAt(j)-'0' : 0;
        res.append(c%10);
        c /= 10;
        i--;
        j--;
    }
    return res.reverse().toString();
}
```

## 相遇问题
### 462
[462 Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)

- 思路：

每次可以对一个数组元素加一或者减一，求最小的改变次数。

这是个典型的**相遇问题**，移动距离最小的方式是所有元素都移动到中位数。理由如下：

设 m 为中位数。a 和 b 是 m 两边的两个元素，
且 b > a。要使 a 和 b 相等，它们总共移动的次数为 b - a，
这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。

设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。

```java
public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int low=0;
    int high=nums.length-1;

    int res=0;
    while(low<high){
        res += nums[high] - nums[low];
        low++;
        high--;
    }
    return res;
}
```

```java
/*
 * 思路二：
 * 使用快速选择找到中位数，时间复杂度 O(N)
 * */
public int minMoves2(int[] nums) {
    //获取该数组的中位数
    int mid=findKthSmallest(nums,nums.length/2);
    int res=0;
    for(int num : nums){
        res += Math.abs(num-mid);
    }
    return res;
}

/**
 * 查找第k小的数值
 */
private int findKthSmallest(int[] nums, int k) {
    int l=0;
    int r=nums.length-1;
    while(l<r){
        int p=partition(nums,l,r);
        if(p==k){
            break;
        }else if(p<k){
            l = p+1;
        }else{
            r = p-1;
        }
    }
    return nums[k];
}

//nums的[l,r]获取切分后的元素下标
private int partition(int[] nums,int l,int r){
    int pivot=nums[l];
    while(l<r){
        //从数组的右端向左扫描找到第一个小于pivot的元素，交换这两个元素
        while(l<r && nums[r]>=pivot){
            r--;
        }
        nums[l]=nums[r];
        //从数组的左端向右扫描找到第一个大于pivot的元素，交换这两个元素
        while(l<r && nums[l]<=pivot){
            l++;
        }
        nums[r]=nums[l];
    }
    nums[l]=pivot;
    return l;
}
```

## 多数投票问题
### 169
[169 Majority Element](https://leetcode.com/problems/majority-element/)

```java
/**
 * 思路一：
 * 先对数组排序，最中间那个数出现次数一定多于 n / 2。
 */
public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length/2];
}
```

```java
/**
 * 思路二：
 * 利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。
 * 可以这么理解该算法：
 * 使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt--。
 * 如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，
 * 但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。
 * 此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。
 */
public int majorityElement(int[] nums) {
    int cnt=0;
    //假设第一个元素是主元素
    int majority=nums[0];
    for(int i=0;i<nums.length;i++){
        int num=nums[i];
        /**
         * 如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，
         * 或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。
         */
        if(cnt==0){
            majority=num;
        }
        /**
         * 剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，
         * 因此继续查找就能找出 majority。
         */
        if(majority==num){
            cnt++;
        }else{
            cnt--;
        }
    }
    return majority;
}
```

## 随机算法
### 478 
[478 Generate Random Point in a Circle](https://leetcode.com/problems/generate-random-point-in-a-circle/)
```java
class Solution {
    private double raduis;
    private double x;
    private double y;
    private Random random;
    
    public Solution(double radius, double x_center, double y_center) {
        this.raduis=radius;
        this.x=x_center;
        this.y=y_center;
        random=new Random();
    }

    public double[] randPoint() {
        //产生random.nextDouble()[0.0,1.0)随机数据
        //x产生[x_center-radius,x_center+radius)
        double randx, randy;
        do{
            randx = x - raduis + randDouble(0, 2 * raduis);
            randy = y-raduis + randDouble(0, 2 * raduis);
        }while (!inCircle(randx,randy));
        return new double[]{randx,randy};
    }

    //[minDouble,maxDopuble]之间的随机数
    private double randDouble(double minDouble, double maxDouble){
        double randNum = (double) random.nextInt(Integer.MAX_VALUE) / Integer.MAX_VALUE; //近似[0.0,1.0]之间的随机数
        return randNum * (maxDouble - minDouble) + minDouble; //近似[minDouble,maxDouble]之间的随机数
    }

    //判断(x0,y0)是否在圆内
    private boolean inCircle(double x0, double y0){
        return (x - x0) * (x - x0) + (y - y0) * (y - y0) <= raduis * raduis;
    }
}
```

### 497 
[497 Random Point in Non-overlapping Rectangles](https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/)

```java
/**
 * 思路：长方形不重叠，则同一长方形内部的整数点被选择的概率相同。
 * 而且并且长方形内部的点被选择的概率等于该长方形的面积。
 * 这里长方形的面积就是求长方形中整数点的个数即可，计算方式是(x2 - x1 + 1) * (y2 - y1 + 1)。
 *
 * 所以，先按照面积随机选择一个长方形，然后再在长方形中随机选择一个整数点。
 */
class Solution {
    private int[][] rects;
    private int[] sum;
    //统计所有的长方形点数
    private int total;
    private Random random;

    public Solution(int[][] rects) {
        this.rects=rects;
        this.random=new Random();

        //统计各个长方形的"面积"
        int[] area=new int[rects.length];
        for(int i=0;i<rects.length;i++){
            int x1=rects[i][0];
            int y1=rects[i][1];
            int x2=rects[i][2];
            int y2=rects[i][3];
            area[i]= (x2 - x1 + 1) * (y2 - y1 + 1);
        }

        //sum中下标和长方形对应
        this.sum=new int[area.length];
        this.total=0;
        for(int i=0;i<area.length;i++){
            total += area[i];
            sum[i]=total;
        }
    }

    public int[] pick() {
        int[] rect = rects[pickRandomRec()];

        // x在 [rect[0],rect[2]]范围内
        int x = rect[0] + random.nextInt(rect[2] - rect[0] + 1);
        //y 在 [rect[1],rect[3]]范围内
        int y = rect[1] + random.nextInt(rect[3] - rect[1] + 1);
        return new int[]{x,y};
    }

    //随机选择一个长方形-->二分查找方式
    private int pickRandomRec(){
        //随机获取在[0,total)之间的一个点
        int target = random.nextInt(total);
        int i = 0, j = sum.length - 1;
        while (i < j) {
            int mid = (i + j) / 2;
            if (sum[mid] > target) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        return i;
    }
}
```

### 519 
### 528