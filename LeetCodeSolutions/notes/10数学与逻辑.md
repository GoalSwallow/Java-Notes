# [第十章 数学与逻辑](#数学与逻辑)

| 章节 | 典型题目 | 相关题目 |
| :---: | :---: | :---: |
| [10-1 智力题](#智力题) |  |  |
| [10-2 蓄水池采样](#蓄水池采样) | [268](#268) [382*](#382) [398](#398) |  |
| [10-3 Rand7](#Rand7) | [470](#470) | | 
| [10-4 随机算法](#随机算法) |  [478]($478) [497](#497) 519 528 | 710 |
 
# 数学与逻辑
## 智力题

## 蓄水池采样
- 问题描述:

给一个无限的数据流，要求随机取出 k 个数。

- 算法:

从第 k+1 个数开始，以k/(k+1)的概率取出这个数，
或者随机替换掉之前已经取出的 k 个数中的一个。

```java
Init : a reservoir with the size： k
//注意下标是从0开始的
for i=k to N-1
     M=random(0, i-1);
     if(M<k)
         SWAP the Mth value and ith value
end for
```
- 证明：

使用**归纳法**进行证明：i表示取出的数据编号

<div align="center"><img src="pics\\math\\math_1.png" width="600"/></div>

### 382
[382 Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/)

```java
/**
* 思路：这里是给定数据流，要求随机取出一个元素，k=1
*/
class Solution {
    private ListNode head;
    private Random random=new Random();
    /** @param head The linked list's head.
    Note that the head is guaranteed to be not null, so it contains at least one node. */
    public Solution(ListNode head) {
        this.head=head;
    }

    /** Returns a random node's value. */
    public int getRandom() {
        ListNode cur=head;
        int res=cur.val;
        int i=1;
        while(cur!=null){
            if(random.nextInt(i)==0){
                res=cur.val;
            }
            cur=cur.next;
            i++;
        }
        return res;
    }
}
```

### 398 
[398 Random Pick Index](https://leetcode.com/problems/random-pick-index/)

```java
class Solution {
    private int[] nums;
    private Random random=new Random();

    public Solution(int[] nums) {
        this.nums=nums;
    }

    public int pick(int target) {
        int res=-1;
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target && random.nextInt(++count)==0){
                //res相当于大小是1的池子，不断替换
                res=i;
            }
        }
        return res;
    }
}
```

## Rand7

由 Rand7 实现 Rand5 很容易，只要调用一次 Rand7，
当得到的数在 [0,5) 之间时，就返回这个数，否则继续调用 Rand7。

如果能由 Rand5 产生一个比 [0,7) 大的随机均匀范围，
那么只要截取 [0,7) 的范围就能实现 Rand7。

先考虑数值的**进制表示**。
对于一个 N 进制的数，每一位上的值的范围在 [0,N) 之间，
并且第 i 位上的值的权值为 N^i。通过这种方式，可以使用 [0,N) 来表示更大的数。

可以参考以上介绍的数值的进制表示，**将 Rand5 产生的 [0,5) 表示成更大的数**。
两位的五进制的数值范围在 [0,4*5+4) => [0,24)，比 Rand7 范围大。

但是大得太多，就会导致转换工作进行很多次，影响效率，
因为如果数在 [7,24) 就需要再进行一次这样的操作。
可以截取 [0, 21) 范围，然后对 7 求余即可解决这个问题。

```java
 public static int rand7() {
     int v = rand5() * 5 + rand5();
     if (v < 21) {
         return v % 7;
     }
     return rand7();
 }
```

### 470 
[470 Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7/)

```java
/**
 * 思路：模仿 rand5-->rand7()
 * rand7-->rand10 --> [0,6*7+6) -->[0,48)
 * 要求数值在 [1,10]之间
 */
class Solution extends SolBase {
    public int rand10() {
        int v=7*(rand7()-1) + (rand7()-1);
        if(v<=39){
            //要求数值在 [1,10]之间,所以需要+1
            return v%10+1;
        }
        return rand10();
    }
}
```

## 随机算法
### 478 
[478 Generate Random Point in a Circle](https://leetcode.com/problems/generate-random-point-in-a-circle/)
```java
class Solution {
    private double raduis;
    private double x;
    private double y;
    private Random random;
    
    public Solution(double radius, double x_center, double y_center) {
        this.raduis=radius;
        this.x=x_center;
        this.y=y_center;
        random=new Random();
    }

    public double[] randPoint() {
        //产生random.nextDouble()[0.0,1.0)随机数据
        //x产生[x_center-radius,x_center+radius)
        double randx, randy;
        do{
            randx = x - raduis + randDouble(0, 2 * raduis);
            randy = y-raduis + randDouble(0, 2 * raduis);
        }while (!inCircle(randx,randy));
        return new double[]{randx,randy};
    }

    //[minDouble,maxDopuble]之间的随机数
    private double randDouble(double minDouble, double maxDouble){
        double randNum = (double) random.nextInt(Integer.MAX_VALUE) / Integer.MAX_VALUE; //近似[0.0,1.0]之间的随机数
        return randNum * (maxDouble - minDouble) + minDouble; //近似[minDouble,maxDouble]之间的随机数
    }

    //判断(x0,y0)是否在圆内
    private boolean inCircle(double x0, double y0){
        return (x - x0) * (x - x0) + (y - y0) * (y - y0) <= raduis * raduis;
    }
}
```

### 497 
[497 Random Point in Non-overlapping Rectangles](https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/)

```java
/**
 * 思路：长方形不重叠，则同一长方形内部的整数点被选择的概率相同。
 * 而且并且长方形内部的点被选择的概率等于该长方形的面积。
 * 这里长方形的面积就是求长方形中整数点的个数即可，计算方式是(x2 - x1 + 1) * (y2 - y1 + 1)。
 *
 * 所以，先按照面积随机选择一个长方形，然后再在长方形中随机选择一个整数点。
 */
class Solution {
    private int[][] rects;
    private int[] sum;
    //统计所有的长方形点数
    private int total;
    private Random random;

    public Solution(int[][] rects) {
        this.rects=rects;
        this.random=new Random();

        //统计各个长方形的"面积"
        int[] area=new int[rects.length];
        for(int i=0;i<rects.length;i++){
            int x1=rects[i][0];
            int y1=rects[i][1];
            int x2=rects[i][2];
            int y2=rects[i][3];
            area[i]= (x2 - x1 + 1) * (y2 - y1 + 1);
        }

        //sum中下标和长方形对应
        this.sum=new int[area.length];
        this.total=0;
        for(int i=0;i<area.length;i++){
            total += area[i];
            sum[i]=total;
        }
    }

    public int[] pick() {
        int[] rect = rects[pickRandomRec()];

        // x在 [rect[0],rect[2]]范围内
        int x = rect[0] + random.nextInt(rect[2] - rect[0] + 1);
        //y 在 [rect[1],rect[3]]范围内
        int y = rect[1] + random.nextInt(rect[3] - rect[1] + 1);
        return new int[]{x,y};
    }

    //随机选择一个长方形-->二分查找方式
    private int pickRandomRec(){
        //随机获取在[0,total)之间的一个点
        int target = random.nextInt(total);
        int i = 0, j = sum.length - 1;
        while (i < j) {
            int mid = (i + j) / 2;
            if (sum[mid] > target) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        return i;
    }
}
```

### 519 
### 528