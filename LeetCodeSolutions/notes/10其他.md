# [第十章 其他](#其他)

| 内容 | 扩展练习 | 难题推荐 |
| :---: | :---: | :---: |
| [位运算](#位运算) | [136](#136) [191](#191) [389](#389) [898*](#898) | |
| [数论](#数论) | [386](#386) | |
| [随机算法](#随机算法) | [268](#268) [382*](#382) [398](#398) 470 478 497 519 528 | 710 |
| 数学问题 | 119 171 319 360 858 | 878 891 |
| 博弈论 | 877 | |
| 数据结构设计 | [155](#155) [380](#380) 900 | 381 895 |
| 其他问题 | 391 780 781 789 795 799 866 880 | 732 899 |

# 其他
## 位运算
### 136 
[136. Single Number](https://leetcode.com/problems/single-number/description/)
```java
public int singleNumber(int[] nums) {
    int ret=nums[0];
    for(int i=1;i<nums.length;i++){
        ret^=nums[i];
    }
    return ret;
}
```
### 191 
[191 Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/)

解法一：
```java
public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int res=0;
    for(int i=0;i<32;i++){
        res+=(n&1);
        n=(n>>1);
    }
    return res;
}
```
解法二:
```java
//bit数组下标是0-15，bit[0]=0,bit[1]=1,表示数字对应的二进制中1的个数
private int[] bit={
        0,1,1,2,
        1,2,2,3,
        1,2,2,3,
        2,3,3,4
};

public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int count=0;
    for(int i=0;i<8;i++){
        int num=n&0xf;
        count+=bit[num];
        n=n>>4;
    }
    return count;
}
```

### 389 
[389 Find the Difference](https://leetcode.com/problems/find-the-difference/description/)
```java
public char findTheDifference(String s, String t) {
    //注意s有可能是空字符串
    if(s.length()==0 && t.length()==1){
        return t.charAt(0);
    }
    char ret=s.charAt(0);
    for(int i=1;i<s.length();i++){
        ret^=s.charAt(i);
    }
    for(int i=0;i<t.length();i++){
        ret^=t.charAt(i);
    }
    return ret;
}
```

### 898
[898 Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/description/)
```java
/**
 * memo[i]表示以A[i]结尾的所有子数组的位或结果，其实是个set。
 * 转移方程式memo[i] =
 * (
 *    for b in memo[i - 1]
 *      (b | A[i])
 * )+ A[i]
 */
public int subarrayBitwiseORs(int[] A) {
    Set<Integer> memo=new HashSet<>();
    Set<Integer> res=new HashSet<>();
    for(int a:A){
        Set<Integer> cur=new HashSet<>();
        for(int b:memo){
            cur.add(b|a);
        }
        cur.add(a);
        memo=cur;
        res.addAll(cur);
    }
    return res.size();
}
```
## 数论
### 386
[386 Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/)

```java
/**
 * 思路一：按字典顺序，首先就会想到字符串，
 * 将数字转换位字符串，然后字符串按照字典顺序排好后，
 * 再将排好序的字符串转换为整数
 */
public List<Integer> lexicalOrder(int n) {
    List<String> tmpRes=new ArrayList<>();
    for(int i=1;i<=n;i++){
        tmpRes.add(i+"");
    }
    Collections.sort(tmpRes);

    List<Integer> res=new ArrayList<>();
    while(!tmpRes.isEmpty()){
        String num=tmpRes.remove(0);
        res.add(Integer.parseInt(num));
    }
    return res;
}
```

```java
/**
 * 思路二：
 * 用函数栈（递归）用来去完成字典序排序。
 */
public List<Integer> lexicalOrder(int n){
    List<Integer> res=new ArrayList<>();
    for(int i=1;i<10;i++){
        if(i<=n){
            generateRes(res,i,n);
        }
    }
    return res;
}

/**
 * 获取以pre开头的数字排序的序列
 * @param pre <=n 的数字的第一个数字
 */
private void generateRes(List<Integer> res,int pre,int n){
    if(pre>n){
        return;
    }
    res.add(pre);
    for(int i=0;i<10;i++){
        if(pre*10+i<=n){
            generateRes(res,pre*10+i,n);
        }
    }
}
```

## 随机算法
### 268
[268 Missing Number](https://leetcode.com/problems/missing-number/)

```java
public int missingNumber(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }

    int res=nums[0]^0;
    for(int i=1;i<n;i++){
        res^=(nums[i]^i);
    }
    res^=n;
    return res;
}
```

### 382
> reservoir sampling 问题

从n个数中随机抽取k个数，要保证每个数都是等概率的。

> 解决:

维护一个大小为k的池子，当池子还没装满时，不停的往里装，当池子装满后，
就要考虑是用新数替换池子中旧的数，还是丢弃新数。

现在的问题是来了一个新数，这个数的编号是x，那么该怎么做呢？
我们首先以k / x的概率来决定是否保存新数，即生成一个[0,1)之间的数，
如果小于k/x，则保留新数，同时随机替换掉池子中的一个数。
如果大于k/x，则丢弃新数。
 
 
[382 Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/)

```java
class Solution {
    private ListNode head;
    private Random random=new Random();
    /** @param head The linked list's head.
    Note that the head is guaranteed to be not null, so it contains at least one node. */
    public Solution(ListNode head) {
        this.head=head;
    }

    /** Returns a random node's value. */
    public int getRandom() {
        ListNode cur=head;
        int res=cur.val;
        int i=1;
        while(cur!=null){
            if(random.nextInt(i)==0){
                res=cur.val;
            }
            cur=cur.next;
            i++;
        }
        return res;
    }
}
```

### 398 
[398 Random Pick Index](https://leetcode.com/problems/random-pick-index/)

```java
class Solution {
    private int[] nums;
    private Random random=new Random();

    public Solution(int[] nums) {
        this.nums=nums;
    }

    public int pick(int target) {
        int res=-1;
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target && random.nextInt(++count)==0){
                //res相当于大小是1的池子，不断替换
                res=i;
            }
        }
        return res;
    }
}
```
### 470 
### 478 
### 497 
### 519 
### 528

## 数据结构设计
### 155
[155 Min Stack](https://leetcode.com/problems/min-stack/description/)
```java
class MinStack {
    //准备两个栈，一个用来存普通元素，一个栈顶的元素始终是当前最小值
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack=new Stack<>();
        minStack=new Stack<>();
    }

    public void push(int x) {
        if(minStack.isEmpty() || x<=minStack.peek()){
            minStack.push(x);
        }
        stack.push(x);
    }

    public void pop() {
        if(stack.peek().equals(minStack.peek())){
            minStack.pop();
        }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### 380
[380 Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)
```java
class RandomizedSet {
    //存储插入的数据
    private ArrayList<Integer> data;
    //存储<value,index>，即存储该值和该值的下标
    private Map<Integer,Integer> valueIndex;
    private Random random;

    /** Initialize your data structure here. */
    public RandomizedSet() {
        data=new ArrayList<>();
        valueIndex=new HashMap<>();
        random=new Random();
    }

    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(!valueIndex.containsKey(val)){
            valueIndex.put(val,data.size());
            data.add(val);
            return true;
        }
        return false;
    }

    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        //这里讲要删除的元素交换到data的最后一个位置，实际上就是将最后一个元素值赋值到val位置，这样保证时间复杂度是O(1)
        if(valueIndex.containsKey(val)){
            //获取val位置
            int index=valueIndex.get(val);
            //val不是最后一个元素
            if(index!=data.size()-1){
                //获取最后一个元素
                int lastEle=data.get(data.size()-1);
                //将最后一个元素值赋值到val位置
                data.set(index,lastEle);
                valueIndex.put(lastEle,index);
            }
            //删除data中最后一个元素
            data.remove(data.size()-1);
            valueIndex.remove(val);
            return true;
        }
        return false;
    }

    /** Get a random element from the set. */
    public int getRandom() {
        return data.get(random.nextInt(data.size()));
    }
}
```