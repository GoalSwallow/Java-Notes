# [第十章 其他](#其他)

| 内容 | 扩展练习 | 难题推荐 |
| :---: | :---: | :---: |
| [位运算](#位运算) | [136](#136) [191](#191)  [268](#268) [389](#389) [898*](#898)| |
| [数论](#数论) | [386](#386) | |
| [数学问题](#数学问题) | [119](#119) [171](#171) [319](#319) 858 | 878 891 |
| 博弈论 | 877 | |
| 数据结构设计 | [155](#155) [380](#380) 900 | 381 895 |

# 其他
## 位运算
### 136 
[136 Single Number](https://leetcode.com/problems/single-number/description/)
```java
public int singleNumber(int[] nums) {
    int ret=nums[0];
    for(int i=1;i<nums.length;i++){
        ret^=nums[i];
    }
    return ret;
}
```
### 191 
[191 Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/)

解法一：
```java
public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int res=0;
    for(int i=0;i<32;i++){
        res+=(n&1);
        n=(n>>1);
    }
    return res;
}
```
解法二:
```java
//bit数组下标是0-15，bit[0]=0,bit[1]=1,表示数字对应的二进制中1的个数
private int[] bit={
        0,1,1,2,
        1,2,2,3,
        1,2,2,3,
        2,3,3,4
};

public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int count=0;
    for(int i=0;i<8;i++){
        int num=n&0xf;
        count+=bit[num];
        n=n>>4;
    }
    return count;
}
```

### 268
[268 Missing Number](https://leetcode.com/problems/missing-number/)

```java
public int missingNumber(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }

    int res=nums[0]^0;
    for(int i=1;i<n;i++){
        res^=(nums[i]^i);
    }
    res^=n;
    return res;
}
```

### 389 
[389 Find the Difference](https://leetcode.com/problems/find-the-difference/description/)
```java
public char findTheDifference(String s, String t) {
    //注意s有可能是空字符串
    if(s.length()==0 && t.length()==1){
        return t.charAt(0);
    }
    char ret=s.charAt(0);
    for(int i=1;i<s.length();i++){
        ret^=s.charAt(i);
    }
    for(int i=0;i<t.length();i++){
        ret^=t.charAt(i);
    }
    return ret;
}
```

### 898
[898 Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/description/)
```java
/**
 * memo[i]表示以A[i]结尾的所有子数组的位或结果，其实是个set。
 * 转移方程式memo[i] =
 * (
 *    for b in memo[i - 1]
 *      (b | A[i])
 * )+ A[i]
 */
public int subarrayBitwiseORs(int[] A) {
    Set<Integer> memo=new HashSet<>();
    Set<Integer> res=new HashSet<>();
    for(int a:A){
        Set<Integer> cur=new HashSet<>();
        for(int b:memo){
            cur.add(b|a);
        }
        cur.add(a);
        memo=cur;
        res.addAll(cur);
    }
    return res.size();
}
```
## 数论
### 386
[386 Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/)

```java
/**
 * 思路一：按字典顺序，首先就会想到字符串，
 * 将数字转换位字符串，然后字符串按照字典顺序排好后，
 * 再将排好序的字符串转换为整数
 */
public List<Integer> lexicalOrder(int n) {
    List<String> tmpRes=new ArrayList<>();
    for(int i=1;i<=n;i++){
        tmpRes.add(i+"");
    }
    Collections.sort(tmpRes);

    List<Integer> res=new ArrayList<>();
    while(!tmpRes.isEmpty()){
        String num=tmpRes.remove(0);
        res.add(Integer.parseInt(num));
    }
    return res;
}
```

```java
/**
 * 思路二：
 * 用函数栈（递归）用来去完成字典序排序。
 */
public List<Integer> lexicalOrder(int n){
    List<Integer> res=new ArrayList<>();
    for(int i=1;i<10;i++){
        if(i<=n){
            generateRes(res,i,n);
        }
    }
    return res;
}

/**
 * 获取以pre开头的数字排序的序列
 * @param pre <=n 的数字的第一个数字
 */
private void generateRes(List<Integer> res,int pre,int n){
    if(pre>n){
        return;
    }
    res.add(pre);
    for(int i=0;i<10;i++){
        if(pre*10+i<=n){
            generateRes(res,pre*10+i,n);
        }
    }
}
```

## 数学问题
### 119 
[119 Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)
```java
public List<Integer> getRow(int rowIndex) {
    int size=rowIndex+1;
    Integer[][] triangle=new Integer[size][size];

    //初始化杨辉三角
    for(int i=0;i<size;i++){
        triangle[i][0]=1;
    }
    for(int i=0;i<size;i++){
       triangle[i][i]=1;
    }

    for(int i=2;i<size;i++){
        for(int j=1;j<i;j++){
            triangle[i][j]=triangle[i-1][j-1]+triangle[i-1][j];
        }
    }

    List<Integer> res= Arrays.asList(triangle[rowIndex]);
    return res;
}
```

```java
/**
 * 改进
 * 空间复杂度只有O(k)
 */
public List<Integer> getRow(int rowIndex) {
    List<Integer> res=new ArrayList<>();

    for(int i=0;i<=rowIndex;i++){
        res.add(1);
        for(int j=i-1;j>=1;j--){
            res.set(j,res.get(j)+res.get(j-1));
        }
    }
    return res;
}
```

### 171 
[171 Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/)

```java
/**
 * 思路：
 * 看成二十六进制就好了
 */
public int titleToNumber(String s) {
    // 'A'就对应1
    // 'B'就对应2
    char[] arr = {
            1,2,3,4,5,6,7,
            8,9,10,11,12,13,14,
            15,16,17,18,19,20,21,
            22,23,24,25,26
    };
    
    int res=0;
    for(int i=s.length()-1;i>=0;i--){
        char c=s.charAt(i);
        res+= arr[c-'A']*Math.pow((int)26,(int)(s.length()-1-i));
    }
    return res;
}
```

### 319 
[319 Bulb Switcher](https://leetcode.com/problems/bulb-switcher/)
```java
/**
 * 思路一：
 *  第 1 轮，你打开所有的灯泡。
 *  第 2 轮，每两个灯泡你关闭一次。
 *  第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。
 *  第 i 轮，每 i 个灯泡切换一次开关。
 *  对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。
 *
 *  但是超时了。
 */
public int bulbSwitch(int n) {
    if(n<=1){
        return n;
    }
    if(n==2){
        return 0;
    }

    int[] bulbs=new int[n];

    //第一轮
    //0表示灯是关的
    //1表示灯是开的
    for(int i=0;i<n;i++){
        bulbs[i] = 1;
    }

    //第二轮
    for(int i=1;i<=n;i++){
        if(i%2==0){
            bulbs[i-1]=0;
        }
    }

    //第三到(n-1)轮
    for (int k = 3; k < n; k++) {
        for(int i=1;i<=n;i++) {
            if(i % k ==0){
                bulbs[i-1]=1-bulbs[i-1];
            }
        }
    }

    //第n轮
    bulbs[n-1]=1-bulbs[n-1];

   int count=0;
   for(int i=0;i<bulbs.length;i++){
       if(bulbs[i]==1){
           count++;
       }
   }
   return count;
}
```

```java
/**
 * 思路二：
 * TODO：当一个灯泡被执行偶数次switch操作时它是关着的，
 * TODO：当被执行奇数次switch操作时它是开着的，那么这题就是要找出哪些编号的灯泡会被执行奇数次操作。
 *
 * 现在假如我们执行第i次操作，
 * 即从编号i开始对编号每次+i进行switch操作(i,2*i,3*i...)，
 * 对于这些灯来说，如果其编号j（j=1,2,3,⋯,n）能够整除i，则编号j的灯需要执行switch操作。
 * 具备这样性质的i是成对出现的，比如：
 * j=12时，编号为12的灯，在第1次，第12次；第2次，第6次；第3次，第4次一定会被执行Switch操作，这样的话，编号为12的灯肯定为灭。
 * 但是当完全平方数36就不一样了，因为他有一个特殊的因数6，这样当i=6时，只能被执行一次Switch操作，
 * 这样推出，完全平方数一定是亮着的，所以本题的关键在于找完全平方数的个数。
 */
public int bulbSwitch(int n) {
    /*int i=0;
    while(i*i<=n){
        i++;
    }
    return i-1;*/
    return (int)Math.sqrt(n);
}
```


### 858
[858 Mirror Reflection](https://leetcode.com/problems/mirror-reflection/)


## 博弈论
### 877
[877 Stone Game](https://leetcode.com/problems/stone-game/)
```java

```

## 数据结构设计
### 155
[155 Min Stack](https://leetcode.com/problems/min-stack/description/)
```java
class MinStack {
    //准备两个栈，一个用来存普通元素，一个栈顶的元素始终是当前最小值
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack=new Stack<>();
        minStack=new Stack<>();
    }

    public void push(int x) {
        if(minStack.isEmpty() || x<=minStack.peek()){
            minStack.push(x);
        }
        stack.push(x);
    }

    public void pop() {
        if(stack.peek().equals(minStack.peek())){
            minStack.pop();
        }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### 380
[380 Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)
```java
class RandomizedSet {
    //存储插入的数据
    private ArrayList<Integer> data;
    //存储<value,index>，即存储该值和该值的下标
    private Map<Integer,Integer> valueIndex;
    private Random random;

    /** Initialize your data structure here. */
    public RandomizedSet() {
        data=new ArrayList<>();
        valueIndex=new HashMap<>();
        random=new Random();
    }

    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(!valueIndex.containsKey(val)){
            valueIndex.put(val,data.size());
            data.add(val);
            return true;
        }
        return false;
    }

    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        //这里讲要删除的元素交换到data的最后一个位置，实际上就是将最后一个元素值赋值到val位置，这样保证时间复杂度是O(1)
        if(valueIndex.containsKey(val)){
            //获取val位置
            int index=valueIndex.get(val);
            //val不是最后一个元素
            if(index!=data.size()-1){
                //获取最后一个元素
                int lastEle=data.get(data.size()-1);
                //将最后一个元素值赋值到val位置
                data.set(index,lastEle);
                valueIndex.put(lastEle,index);
            }
            //删除data中最后一个元素
            data.remove(data.size()-1);
            valueIndex.remove(val);
            return true;
        }
        return false;
    }

    /** Get a random element from the set. */
    public int getRandom() {
        return data.get(random.nextInt(data.size()));
    }
}
```

### 900
[900 RLE Iterator](https://leetcode.com/problems/rle-iterator/)