# [第十章 其他](#其他)

| 内容 | 扩展练习 | 难题推荐 |
| :---: | :---: | :---: |
| [位运算](#位运算) | [136](#136) [191](#191) [389](#389) [898*](#898) | |
| 数论 | 386 | |
| 线段树 | 307 370 218 | 699 715 308 |
| Trie | 208 720 676 677 648 211 | |
| 并查集 | 737 721 684 | |
| 图论 | 787 886 | 685 765 864 882 |
| 随机算法 | 268 382 398 470 478 497 519 528 | 710 |
| 数学问题 | 119 171 319 360 858 | 878 891 |
| 博弈论 | 877 | |
| 数据结构设计 | [155](#155) [380](#380) 900 | 381 895 |
| 其他问题 | 391 780 781 789 795 799 866 880 | 732 899 |

# 其他
## 位运算
### 136 
[136. Single Number](https://leetcode.com/problems/single-number/description/)
```java
public int singleNumber(int[] nums) {
    int ret=nums[0];
    for(int i=1;i<nums.length;i++){
        ret^=nums[i];
    }
    return ret;
}
```
### 191 
[191 Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/)

解法一：
```java
public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int res=0;
    for(int i=0;i<32;i++){
        res+=(n&1);
        n=(n>>1);
    }
    return res;
}
```
解法二:
```java
//bit数组下标是0-15，bit[0]=0,bit[1]=1,表示数字对应的二进制中1的个数
private int[] bit={
        0,1,1,2,
        1,2,2,3,
        1,2,2,3,
        2,3,3,4
};

public int hammingWeight(int n){
    if(n==0){
        return 0;
    }
    int count=0;
    for(int i=0;i<8;i++){
        int num=n&0xf;
        count+=bit[num];
        n=n>>4;
    }
    return count;
}
```

### 389 
[389 Find the Difference](https://leetcode.com/problems/find-the-difference/description/)
```java
public char findTheDifference(String s, String t) {
    //注意s有可能是空字符串
    if(s.length()==0 && t.length()==1){
        return t.charAt(0);
    }
    char ret=s.charAt(0);
    for(int i=1;i<s.length();i++){
        ret^=s.charAt(i);
    }
    for(int i=0;i<t.length();i++){
        ret^=t.charAt(i);
    }
    return ret;
}
```

### 898
[898 Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/description/)
```java
/**
 * memo[i]表示以A[i]结尾的所有子数组的位或结果，其实是个set。
 * 转移方程式memo[i] =
 * (
 *    for b in memo[i - 1]
 *      (b | A[i])
 * )+ A[i]
 */
public int subarrayBitwiseORs(int[] A) {
    Set<Integer> memo=new HashSet<>();
    Set<Integer> res=new HashSet<>();
    for(int a:A){
        Set<Integer> cur=new HashSet<>();
        for(int b:memo){
            cur.add(b|a);
        }
        cur.add(a);
        memo=cur;
        res.addAll(cur);
    }
    return res.size();
}
```

## 数据结构设计
### 155
[155 Min Stack](https://leetcode.com/problems/min-stack/description/)
```java
class MinStack {
    //准备两个栈，一个用来存普通元素，一个栈顶的元素始终是当前最小值
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack=new Stack<>();
        minStack=new Stack<>();
    }

    public void push(int x) {
        if(minStack.isEmpty() || x<=minStack.peek()){
            minStack.push(x);
        }
        stack.push(x);
    }

    public void pop() {
        if(stack.peek().equals(minStack.peek())){
            minStack.pop();
        }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### 380
[380 Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)
```java
class RandomizedSet {
    //存储插入的数据
    private ArrayList<Integer> data;
    //存储<value,index>，即存储该值和该值的下标
    private Map<Integer,Integer> valueIndex;
    private Random random;

    /** Initialize your data structure here. */
    public RandomizedSet() {
        data=new ArrayList<>();
        valueIndex=new HashMap<>();
        random=new Random();
    }

    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(!valueIndex.containsKey(val)){
            valueIndex.put(val,data.size());
            data.add(val);
            return true;
        }
        return false;
    }

    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        //这里讲要删除的元素交换到data的最后一个位置，实际上就是将最后一个元素值赋值到val位置，这样保证时间复杂度是O(1)
        if(valueIndex.containsKey(val)){
            //获取val位置
            int index=valueIndex.get(val);
            //val不是最后一个元素
            if(index!=data.size()-1){
                //获取最后一个元素
                int lastEle=data.get(data.size()-1);
                //将最后一个元素值赋值到val位置
                data.set(index,lastEle);
                valueIndex.put(lastEle,index);
            }
            //删除data中最后一个元素
            data.remove(data.size()-1);
            valueIndex.remove(val);
            return true;
        }
        return false;
    }

    /** Get a random element from the set. */
    public int getRandom() {
        return data.get(random.nextInt(data.size()));
    }
}
```