<!-- GFM-TOC -->
* [最短路径](#最短路径)
    * [Dijkstra单源最短路径算法](#Dijkstra单源最短路径算法)
<!-- GFM-TOC -->

# 最短路径
## Dijkstra单源最短路径算法
**前提：图中不能有负权边**

图中的蓝色顶点表示已加入最短路径树。红色的边就是最短路径。

图的右方左部分是索引堆，右部分是distTo[v] (表示从源点到v的已知最短路径长度)。


Dijkstra算法思路 ：

<div align="center"><img src="pics//shortestPath//16_1.png" width="500"/></div>

将0顶点开始，将访问顶点1、2、3

<div align="center"><img src="pics//shortestPath//16_2.png" width="500"/></div>

到没有访问过的顶点的最短路径是2，也就是顶点2

<div align="center"><img src="pics//shortestPath//16_3.png" width="500"/></div>

从2开始，将访问1、3、4。

先访问顶点 1 ，则0->2->1的路径就为3，此时不需要考虑0->1权为5的边了。

<div align="center"><img src="pics//shortestPath//16_4.png" width="500"/></div>

访问 顶点 4 ，则 0->2->4的路径长为7。

<div align="center"><img src="pics//shortestPath//16_5.png" width="500"/></div>

访问 顶点 3，则 0->2->3的路径长为5，此时就不需要考虑0->3权为6的边了。

<div align="center"><img src="pics//shortestPath//16_6.png" width="500"/></div>

此时所能到达的最短路径是顶点1。

<div align="center"><img src="pics//shortestPath//16_7.png" width="500"/></div>

考虑顶点1的邻边，1->4的路径更小。

<div align="center"><img src="pics//shortestPath//16_8.png" width="500"/></div>

此时所能到达的最短路径是顶点4。

<div align="center"><img src="pics//shortestPath//16_9.png" width="500"/></div>

此时所能到达的最短路径是顶点3.

<div align="center"><img src="pics//shortestPath//16_10.png" width="500"/></div>



