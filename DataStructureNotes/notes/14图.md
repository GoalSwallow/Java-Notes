<!-- GFM-TOC -->
* [图](#图)
   * [图论基础](#图论基础)
   * [图的表示](#图的表示)
   * [相邻点迭代器](#相邻点迭代器)
   * [图的算法框架](#图的算法框架)
   * [深度优先遍历和连通分量](#深度优先遍历和连通分量)
   * [寻路](#寻路)
   * [广度优先遍历和最短路径](#广度优先遍历和最短路径)
   * [迷宫生成](#迷宫生成)
   * [ps抠图](#ps抠图)
<!-- GFM-TOC -->
	
# 图

## 图论基础
[参考 图论](https://blog.csdn.net/saltriver/article/details/54428685)

## 图的表示
### 1.邻接矩阵

- 邻接矩阵表示无向图

<div align="center"><img src="pics//graph//14_1.png" width="600"/></div>

- 邻接矩阵表示有向图

<div align="center"><img src="pics//graph//14_2.png" width="600"/></div>

```java
/**
 * 稠密图-邻接矩阵
 */
public class DenseGraph {

    private int n;  // 节点数
    private int m;  // 边数
    private boolean directed;   // 是否为有向图
    private boolean[][] g;      // 图的具体数据

    // 构造函数
    public DenseGraph( int n , boolean directed ){
        assert n >= 0;
        this.n = n;
        this.m = 0;    // 初始化没有任何边
        this.directed = directed;
        // g初始化为n*n的布尔矩阵, 每一个g[i][j]均为false, 表示没有任和边
        // false为boolean型变量的默认值
        g = new boolean[n][n];
    }

    public int V(){ return n;} // 返回节点个数
    public int E(){ return m;} // 返回边的个数

    // 向图中添加一个边
    public void addEdge( int v , int w ){

        assert v >= 0 && v < n ;
        assert w >= 0 && w < n ;

        if( hasEdge( v , w ) ){
            return; 
        }
           

        g[v][w] = true;
        if( !directed ){
            g[w][v] = true;
        }
        m ++;
    }

    // 验证图中是否有从v到w的边
    boolean hasEdge( int v , int w ){
        assert v >= 0 && v < n ;
        assert w >= 0 && w < n ;
        return g[v][w];
    }
}
```

### 2.邻接表
- 邻接表表示无向图

<div align="center"><img src="pics//graph//14_3.png" width="600"/></div>

- 邻接表表示有向图

<div align="center"><img src="pics//graph//14_4.png" width="600"/></div>

```java
public class SparseGraph {

    private int n;  // 节点数
    private int m;  // 边数
    private boolean directed;    // 是否为有向图
    private Vector<Integer>[] g; // 图的具体数据

    // 构造函数
    public SparseGraph( int n , boolean directed ){
        assert n >= 0;
        this.n = n;
        this.m = 0;    // 初始化没有任何边
        this.directed = directed;
        // g初始化为n个空的vector, 表示每一个g[i]都为空, 即没有任和边
        g = (Vector<Integer>[])new Vector[n];
        for(int i = 0 ; i < n ; i ++){
            g[i] = new Vector<Integer>();
        }
    }

    public int V(){ return n;} // 返回节点个数
    public int E(){ return m;} // 返回边的个数

    // 向图中添加一个边
    public void addEdge( int v, int w ){

        assert v >= 0 && v < n ;
        assert w >= 0 && w < n ;

        g[v].add(w);
        if( v != w && !directed ){
            g[w].add(v);
        }
        m ++;
    }

    // 验证图中是否有从v到w的边 -->时间复杂度：O(n)
    boolean hasEdge( int v , int w ){

        assert v >= 0 && v < n ;
        assert w >= 0 && w < n ;

        for( int i = 0 ; i < g[v].size() ; i ++ ){
            if( g[v].elementAt(i) == w ){
                return true;
            }
        }
        return false;
    }
}
```

## 相邻点迭代器

## 图的算法框架

## 深度优先遍历和连通分量

## 寻路

## 广度优先遍历和最短路径

## 迷宫生成

## ps抠图