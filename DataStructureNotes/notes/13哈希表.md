<!-- GFM-TOC -->
* [哈希表](#哈希表)
    * [什么是哈希表](#什么是哈希表)
    * [哈希函数的设计](#哈希函数的设计)
<!-- GFM-TOC -->

# 哈希表
## 什么是哈希表
哈希表表（Hash table，散列表），是根据关键码值(Key value)而直接进行访问的数据结构。
也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
这个映射函数叫做**哈希函数**，存放记录的数组叫做散列表。
给定表M，存在函数f(key)，对任意给定的关键字值key，
代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

举个例子：统计 s="fsgererhgerh"中字符出现次数（其中s只包含小写字母）

我们通常会使用这样的数组： int[] freq=new int[26];

这个freq就是一个哈希表

其中每一个字符都和一个索引对应：

<div align="center"><img src="pics//hash//13_1.png" width="600"/></div>

哈希表设计思想：

- 哈希表充分体现了算法设计领域的经典思想：空间换时间。

- 哈希表是空间和时间之间的平衡

- 哈希函数的设计十分重要

- “键”通过哈希函数得到的“索引”分布越均匀越好

## 哈希函数的设计
哈希函数设计原则：

1.一致性：如果a==b,则hash(a)==hash(b)，反之，则不成立

2.高效性：计算高效简便

3.均匀性：哈希值均匀分布

### 整数
- 小范围正整数：

**直接使用**

- 小范围负整数：

**进行偏移**，比如[-100,100]，左右区间都+100，进行偏移，得到[0,200]

- 大整数：比如身份证号 342401199607198888

通常做法：**取模**

1.取后4位，相当于 mod 10000 -->获得 8888

2.取后6位，相当于mod 1000000 --> 获得 198888，但是获取的数据不可能超过32万，
因为在身份证中19为表示的是一个月的某一天，最大值是31，即所谓**分布不均匀**问题;
只取后6位，就**没有利用所有信息**。

3.解决2中的两个问题的简单解决办法：模一个**素数**

### 浮点型
浮点型在计算机中也是32位或者64位的二进制表示的，只不过是计算机解析成浮点数的，
因此，可以根据浮点数的二进制表示，转化为整数。

### 字符串
转换成整型处理

"163" --> 1 * 10^2 + 6 * 10^1 + 3 * 10^0

"code" --> c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0

"code"也可以这样转换：

"code" --> c * B^3 + o * B^2 + d * B^1 + e * B^0  

(26和B都是进制，合理选择进制即可)

因此有如下哈希函数：

hash("code")= (c * B^3 + o * B^2 + d * B^1 + e * B^0) % M

进一步转化：

hash("code")= (((c * B + o)*B + d)*B + e) % M

(((c * B + o)*B + d)*B + e)数据有可能过大，再进一步进行转化：

hash("code")= ((((c % M)* B + o) % M * B + d) %M * B + e) % M

对应代码如下：
```java
int hash=0;
for(int i=0;i<s.length();i++){
    hash=( hash * B + s.charAt(i) )%M;
}

```

### 复合类型
转化成整型处理

比如：对于自定义的Date

```java
class Date{
    int year;
    int month;
    int day;
}
```

hash(date)=(((date.year % M ) * B + date.month ) % M * B + date.day) % M

- 注意：以上都是都是转化为整型处理，但这并不是唯一的方法。