<!-- GFM-TOC -->
* [集合和映射](#集合和映射)
    * [集合](#集合)
        * [基于二分搜索树的集合实现](#基于二分搜索树的集合实现)
        * [基于链表的集合实现](#基于链表的集合实现)
<!-- GFM-TOC -->
# 集合和映射
## 集合
- 集合的基本架构：

<div align="center"><img src="pics//setAndMap//set_1.png" width="600"/></div>

```java
public interface Set<E> {
    void add(E e);
    void remove(E e);
    boolean contains(E e);
    int getSize();
    boolean isEmpty();
}
```

### 基于二分搜索树的集合实现
```java
public class BSTSet<E extends Comparable<E>> implements Set<E>{
    private BST<E> bst;

    public BSTSet(){
        bst=new BST<>();
    }

    @Override
    public void add(E e) {
        bst.add(e);
    }

    @Override
    public void remove(E e) {
        bst.del(e);
    }

    @Override
    public boolean contains(E e) {
        return bst.contains(e);
    }

    @Override
    public int getSize() {
        return bst.size();
    }

    @Override
    public boolean isEmpty() {
        return bst.isEmpty();
    }
}
```

## 基于链表的集合实现
```java
public class LinkedListSet<E> implements Set<E>{
   private LinkedList<E> linkedList;

   public LinkedListSet(){
       linkedList=new LinkedList<>();
   }

    @Override
    public void add(E e) {
        if(!contains(e)){
            linkedList.addFirst(e);
        }
    }

    @Override
    public void remove(E e) {
        if(contains(e)){
            linkedList.removeElement(e);
        }
    }

    @Override
    public boolean contains(E e) {
        return linkedList.contains(e);
    }

    @Override
    public int getSize() {
        return linkedList.getSize();
    }

    @Override
    public boolean isEmpty() {
        return linkedList.isEmpty();
    }
}
```

## 集合的时间复杂度分析

<div align="center"><img src="pics//setAndMap//set_2.png" width="400"/></div>

- log n 和n的差距

<div align="center"><img src="pics//setAndMap//set_3.png" width="400"/></div>

- 同样的数据，有可能构造不同的BST

<div align="center"><img src="pics//setAndMap//set_4.png" width="400"/></div>

上图右边的BST就退化成了链表了。