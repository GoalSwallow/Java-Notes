<!-- GFM-TOC -->
* [堆排序](#堆排序)
<!-- GFM-TOC -->

	4-1 为什么使用堆
	4-2 堆的基本存储
	4-3 Shift Up
	4-4 Shift Down
	4-5 基础堆排序和Heapify
	4-6 优化的堆排序
	4-7 排序算法总结
	4-8 索引堆
	4-9 索引堆的优化
	4-10 和堆相关的其他问题
 ## 堆排序
    
    ### 1. 堆
    
    堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。
    
    堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。
    
    <div align="center"> <img src="pics/f3080f83-6239-459b-8e9c-03b6641f7815.png" width="200"/> </div><br>
    
    ```java
    public class Heap<T extends Comparable<T>> {
    
        private T[] heap;
        private int N = 0;
    
        public Heap(int maxN) {
            this.heap = (T[]) new Comparable[maxN + 1];
        }
    
        public boolean isEmpty() {
            return N == 0;
        }
    
        public int size() {
            return N;
        }
    
        private boolean less(int i, int j) {
            return heap[i].compareTo(heap[j]) < 0;
        }
    
        private void swap(int i, int j) {
            T t = heap[i];
            heap[i] = heap[j];
            heap[j] = t;
        }
    }
    ```
    
    ### 2. 上浮和下沉
    
    在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。
    
    <div align="center"> <img src="pics/33ac2b23-cb85-4e99-bc41-b7b7199fad1c.png" width="400"/> </div><br>
    
    ```java
    private void swim(int k) {
        while (k > 1 && less(k / 2, k)) {
            swap(k / 2, k);
            k = k / 2;
        }
    }
    ```
    
    类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。
    
    <div align="center"> <img src="pics/72f0ff69-138d-4e54-b7ac-ebe025d978dc.png" width="400"/> </div><br>
    
    ```java
    private void sink(int k) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(j, j + 1))
                j++;
            if (!less(k, j))
                break;
            swap(k, j);
            k = j;
        }
    }
    ```
    
    ### 3. 插入元素
    
    将新元素放到数组末尾，然后上浮到合适的位置。
    
    ```java
    public void insert(Comparable v) {
        heap[++N] = v;
        swim(N);
    }
    ```
    
    ### 4. 删除最大元素
    
    从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。
    
    ```java
    public T delMax() {
        T max = heap[1];
        swap(1, N--);
        heap[N + 1] = null;
        sink(1);
        return max;
    }
    ```
    
    ### 5. 堆排序
    
    把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。
    
    #### 5.1 构建堆
    
    无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。
    
    <div align="center"> <img src="pics/b84ba6fb-312b-4e69-8c77-fb6eb6fb38d4.png" width="300"/> </div><br>
    
    #### 5.2 交换堆顶元素与最后一个元素
    
    交换之后需要进行下沉操作维持堆的有序状态。
    
    <div align="center"> <img src="pics/51fb761d-8ce0-4472-92ff-2f227ac7888a.png" width="270"/> </div><br>
    
    <div align="center"> <img src="pics/b20a3466-44b4-445e-87c7-dd4fb9ef44b2.png" width="350"/> </div><br>
    
    ```java
    public class HeapSort<T extends Comparable<T>> extends Sort<T> {
        /**
         * 数组第 0 个位置不能有元素
         */
        @Override
        public void sort(T[] nums) {
            int N = nums.length - 1;
            for (int k = N / 2; k >= 1; k--)
                sink(nums, k, N);
    
            while (N > 1) {
                swap(nums, 1, N--);
                sink(nums, 1, N);
            }
        }
    
        private void sink(T[] nums, int k, int N) {
            while (2 * k <= N) {
                int j = 2 * k;
                if (j < N && less(nums, j, j + 1))
                    j++;
                if (!less(nums, k, j))
                    break;
                swap(nums, k, j);
                k = j;
            }
        }
    
        private boolean less(T[] nums, int i, int j) {
            return nums[i].compareTo(nums[j]) < 0;
        }
    }
    ```
    
    ### 6. 分析
    
    一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。
    
    对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。
    
    堆排序是一种原地排序，没有利用额外的空间。
    
    现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。
    